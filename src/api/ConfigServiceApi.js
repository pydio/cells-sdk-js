/**
 * Pydio Cells Rest API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import ConfigurationMessageDataIsAnJsonRepresentationOfAnyValue from '../model/ConfigurationMessageDataIsAnJsonRepresentationOfAnyValue';
import CtlService from '../model/CtlService';
import DataSourceObjectDescription from '../model/DataSourceObjectDescription';
import EncryptionAdminCreateKeyRequest from '../model/EncryptionAdminCreateKeyRequest';
import EncryptionAdminCreateKeyResponse from '../model/EncryptionAdminCreateKeyResponse';
import EncryptionAdminDeleteKeyRequest from '../model/EncryptionAdminDeleteKeyRequest';
import EncryptionAdminDeleteKeyResponse from '../model/EncryptionAdminDeleteKeyResponse';
import EncryptionAdminExportKeyRequest from '../model/EncryptionAdminExportKeyRequest';
import EncryptionAdminExportKeyResponse from '../model/EncryptionAdminExportKeyResponse';
import EncryptionAdminImportKeyRequest from '../model/EncryptionAdminImportKeyRequest';
import EncryptionAdminImportKeyResponse from '../model/EncryptionAdminImportKeyResponse';
import EncryptionAdminListKeysRequest from '../model/EncryptionAdminListKeysRequest';
import EncryptionAdminListKeysResponse from '../model/EncryptionAdminListKeysResponse';
import ObjectDataSource from '../model/ObjectDataSource';
import RegistryListRequest from '../model/RegistryListRequest';
import RegistryListResponse from '../model/RegistryListResponse';
import RestConfiguration from '../model/RestConfiguration';
import RestControlServiceRequest from '../model/RestControlServiceRequest';
import RestCreatePeerFolderRequest from '../model/RestCreatePeerFolderRequest';
import RestCreatePeerFolderResponse from '../model/RestCreatePeerFolderResponse';
import RestCreateStorageBucketRequest from '../model/RestCreateStorageBucketRequest';
import RestCreateStorageBucketResponse from '../model/RestCreateStorageBucketResponse';
import RestDataSourceCollection from '../model/RestDataSourceCollection';
import RestDeleteDataSourceResponse from '../model/RestDeleteDataSourceResponse';
import RestDiscoveryResponse from '../model/RestDiscoveryResponse';
import RestError from '../model/RestError';
import RestListPeerFoldersRequest from '../model/RestListPeerFoldersRequest';
import RestListPeersAddressesResponse from '../model/RestListPeersAddressesResponse';
import RestListProcessesRequest from '../model/RestListProcessesRequest';
import RestListProcessesResponse from '../model/RestListProcessesResponse';
import RestListSitesResponse from '../model/RestListSitesResponse';
import RestListStorageBucketsRequest from '../model/RestListStorageBucketsRequest';
import RestNodesCollection from '../model/RestNodesCollection';
import RestOpenApiResponse from '../model/RestOpenApiResponse';
import RestSchedulerActionFormResponse from '../model/RestSchedulerActionFormResponse';
import RestSchedulerActionsResponse from '../model/RestSchedulerActionsResponse';
import RestServiceCollection from '../model/RestServiceCollection';
import RestVersioningPolicyCollection from '../model/RestVersioningPolicyCollection';
import TreeVersioningPolicy from '../model/TreeVersioningPolicy';

/**
* ConfigService service.
* @module api/ConfigServiceApi
* @version 4.0
*/
export default class ConfigServiceApi {

    /**
    * Constructs a new ConfigServiceApi. 
    * @alias module:api/ConfigServiceApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }



    /**
     * Publish Forms definition for building screens in frontend
     * @param {String} ServiceName Retrieve a configuration form for a given service
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestDiscoveryResponse} and HTTP response
     */
    configFormsDiscoveryWithHttpInfo(ServiceName) {
      let postBody = null;
      // verify the required parameter 'ServiceName' is set
      if (ServiceName === undefined || ServiceName === null) {
        throw new Error("Missing the required parameter 'ServiceName' when calling configFormsDiscovery");
      }

      let pathParams = {
        'ServiceName': ServiceName
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = RestDiscoveryResponse;
      return this.apiClient.callApi(
        '/config/discovery/forms/{ServiceName}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Publish Forms definition for building screens in frontend
     * @param {String} ServiceName Retrieve a configuration form for a given service
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestDiscoveryResponse}
     */
    configFormsDiscovery(ServiceName) {
      return this.configFormsDiscoveryWithHttpInfo(ServiceName)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * [Not Implemented]  Start/Stop a service
     * @param {module:model/RestControlServiceRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CtlService} and HTTP response
     */
    controlServiceWithHttpInfo(body) {
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling controlService");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CtlService;
      return this.apiClient.callApi(
        '/config/ctl', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * [Not Implemented]  Start/Stop a service
     * @param {module:model/RestControlServiceRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CtlService}
     */
    controlService(body) {
      return this.controlServiceWithHttpInfo(body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create a new master key
     * @param {module:model/EncryptionAdminCreateKeyRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/EncryptionAdminCreateKeyResponse} and HTTP response
     */
    createEncryptionKeyWithHttpInfo(body) {
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createEncryptionKey");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = EncryptionAdminCreateKeyResponse;
      return this.apiClient.callApi(
        '/config/encryption/create', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create a new master key
     * @param {module:model/EncryptionAdminCreateKeyRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EncryptionAdminCreateKeyResponse}
     */
    createEncryptionKey(body) {
      return this.createEncryptionKeyWithHttpInfo(body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create a folder on a given path for a given peer (filesystem)
     * @param {String} PeerAddress Restrict listing to a given peer
     * @param {module:model/RestCreatePeerFolderRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestCreatePeerFolderResponse} and HTTP response
     */
    createPeerFolderWithHttpInfo(PeerAddress, body) {
      let postBody = body;
      // verify the required parameter 'PeerAddress' is set
      if (PeerAddress === undefined || PeerAddress === null) {
        throw new Error("Missing the required parameter 'PeerAddress' when calling createPeerFolder");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createPeerFolder");
      }

      let pathParams = {
        'PeerAddress': PeerAddress
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = RestCreatePeerFolderResponse;
      return this.apiClient.callApi(
        '/config/peers/{PeerAddress}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create a folder on a given path for a given peer (filesystem)
     * @param {String} PeerAddress Restrict listing to a given peer
     * @param {module:model/RestCreatePeerFolderRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestCreatePeerFolderResponse}
     */
    createPeerFolder(PeerAddress, body) {
      return this.createPeerFolderWithHttpInfo(PeerAddress, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Buckets on a given object storage
     * @param {String} BucketName 
     * @param {module:model/RestCreateStorageBucketRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestCreateStorageBucketResponse} and HTTP response
     */
    createStorageBucketWithHttpInfo(BucketName, body) {
      let postBody = body;
      // verify the required parameter 'BucketName' is set
      if (BucketName === undefined || BucketName === null) {
        throw new Error("Missing the required parameter 'BucketName' when calling createStorageBucket");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createStorageBucket");
      }

      let pathParams = {
        'BucketName': BucketName
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = RestCreateStorageBucketResponse;
      return this.apiClient.callApi(
        '/config/buckets/{BucketName}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Buckets on a given object storage
     * @param {String} BucketName 
     * @param {module:model/RestCreateStorageBucketRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestCreateStorageBucketResponse}
     */
    createStorageBucket(BucketName, body) {
      return this.createStorageBucketWithHttpInfo(BucketName, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete a datasource
     * @param {String} Name Name of the data source (max length 34)
     * @param {Object} opts Optional parameters
     * @param {Boolean} opts.Disabled Whether this data source is disabled or running.
     * @param {module:model/String} opts.StorageType Type of underlying storage (LOCAL, S3, AZURE, GCS). (default to 'LOCAL')
     * @param {String} opts.ObjectsServiceName Corresponding objects service name (underlying s3 service).
     * @param {String} opts.ObjectsHost Corresponding objects service host.
     * @param {Number} opts.ObjectsPort Corresponding objects service port.
     * @param {Boolean} opts.ObjectsSecure Corresponding objects service connection type.
     * @param {String} opts.ObjectsBucket Corresponding objects service bucket.
     * @param {String} opts.ObjectsBaseFolder Corresponding objects service base folder inside the bucket.
     * @param {String} opts.ApiKey Corresponding objects service api key.
     * @param {String} opts.ApiSecret Corresponding objects service api secret.
     * @param {String} opts.PeerAddress Peer address of the data source.
     * @param {Boolean} opts.Watch Not implemented, whether to watch for underlying changes on the FS.
     * @param {Boolean} opts.FlatStorage Store data in flat format (object-storage like).
     * @param {Boolean} opts.SkipSyncOnRestart Do not trigger resync at start.
     * @param {module:model/String} opts.EncryptionMode Type of encryption applied before sending data to storage. (default to 'CLEAR')
     * @param {String} opts.EncryptionKey Encryption key used for encrypting data.
     * @param {String} opts.VersioningPolicyName Versioning policy describes how files are kept in the versioning queue.
     * @param {Number} opts.CreationDate Data Source creation date.
     * @param {Number} opts.LastSynchronizationDate Data Source last synchronization date.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestDeleteDataSourceResponse} and HTTP response
     */
    deleteDataSourceWithHttpInfo(Name, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'Name' is set
      if (Name === undefined || Name === null) {
        throw new Error("Missing the required parameter 'Name' when calling deleteDataSource");
      }

      let pathParams = {
        'Name': Name
      };
      let queryParams = {
        'Disabled': opts['Disabled'],
        'StorageType': opts['StorageType'],
        'ObjectsServiceName': opts['ObjectsServiceName'],
        'ObjectsHost': opts['ObjectsHost'],
        'ObjectsPort': opts['ObjectsPort'],
        'ObjectsSecure': opts['ObjectsSecure'],
        'ObjectsBucket': opts['ObjectsBucket'],
        'ObjectsBaseFolder': opts['ObjectsBaseFolder'],
        'ApiKey': opts['ApiKey'],
        'ApiSecret': opts['ApiSecret'],
        'PeerAddress': opts['PeerAddress'],
        'Watch': opts['Watch'],
        'FlatStorage': opts['FlatStorage'],
        'SkipSyncOnRestart': opts['SkipSyncOnRestart'],
        'EncryptionMode': opts['EncryptionMode'],
        'EncryptionKey': opts['EncryptionKey'],
        'VersioningPolicyName': opts['VersioningPolicyName'],
        'CreationDate': opts['CreationDate'],
        'LastSynchronizationDate': opts['LastSynchronizationDate']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = RestDeleteDataSourceResponse;
      return this.apiClient.callApi(
        '/config/datasource/{Name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete a datasource
     * @param {String} Name Name of the data source (max length 34)
     * @param {Object} opts Optional parameters
     * @param {Boolean} opts.Disabled Whether this data source is disabled or running.
     * @param {module:model/String} opts.StorageType Type of underlying storage (LOCAL, S3, AZURE, GCS). (default to 'LOCAL')
     * @param {String} opts.ObjectsServiceName Corresponding objects service name (underlying s3 service).
     * @param {String} opts.ObjectsHost Corresponding objects service host.
     * @param {Number} opts.ObjectsPort Corresponding objects service port.
     * @param {Boolean} opts.ObjectsSecure Corresponding objects service connection type.
     * @param {String} opts.ObjectsBucket Corresponding objects service bucket.
     * @param {String} opts.ObjectsBaseFolder Corresponding objects service base folder inside the bucket.
     * @param {String} opts.ApiKey Corresponding objects service api key.
     * @param {String} opts.ApiSecret Corresponding objects service api secret.
     * @param {String} opts.PeerAddress Peer address of the data source.
     * @param {Boolean} opts.Watch Not implemented, whether to watch for underlying changes on the FS.
     * @param {Boolean} opts.FlatStorage Store data in flat format (object-storage like).
     * @param {Boolean} opts.SkipSyncOnRestart Do not trigger resync at start.
     * @param {module:model/String} opts.EncryptionMode Type of encryption applied before sending data to storage. (default to 'CLEAR')
     * @param {String} opts.EncryptionKey Encryption key used for encrypting data.
     * @param {String} opts.VersioningPolicyName Versioning policy describes how files are kept in the versioning queue.
     * @param {Number} opts.CreationDate Data Source creation date.
     * @param {Number} opts.LastSynchronizationDate Data Source last synchronization date.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestDeleteDataSourceResponse}
     */
    deleteDataSource(Name, opts) {
      return this.deleteDataSourceWithHttpInfo(Name, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete an existing master key
     * @param {module:model/EncryptionAdminDeleteKeyRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/EncryptionAdminDeleteKeyResponse} and HTTP response
     */
    deleteEncryptionKeyWithHttpInfo(body) {
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling deleteEncryptionKey");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = EncryptionAdminDeleteKeyResponse;
      return this.apiClient.callApi(
        '/config/encryption/delete', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete an existing master key
     * @param {module:model/EncryptionAdminDeleteKeyRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EncryptionAdminDeleteKeyResponse}
     */
    deleteEncryptionKey(body) {
      return this.deleteEncryptionKeyWithHttpInfo(body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Publish available endpoints
     * @param {Object} opts Optional parameters
     * @param {String} opts.EndpointType Filter result to a specific endpoint type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestDiscoveryResponse} and HTTP response
     */
    endpointsDiscoveryWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'EndpointType': opts['EndpointType']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = RestDiscoveryResponse;
      return this.apiClient.callApi(
        '/config/discovery', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Publish available endpoints
     * @param {Object} opts Optional parameters
     * @param {String} opts.EndpointType Filter result to a specific endpoint type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestDiscoveryResponse}
     */
    endpointsDiscovery(opts) {
      return this.endpointsDiscoveryWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Export a master key for backup purpose, protected with a password
     * @param {module:model/EncryptionAdminExportKeyRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/EncryptionAdminExportKeyResponse} and HTTP response
     */
    exportEncryptionKeyWithHttpInfo(body) {
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling exportEncryptionKey");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = EncryptionAdminExportKeyResponse;
      return this.apiClient.callApi(
        '/config/encryption/export', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Export a master key for backup purpose, protected with a password
     * @param {module:model/EncryptionAdminExportKeyRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EncryptionAdminExportKeyResponse}
     */
    exportEncryptionKey(body) {
      return this.exportEncryptionKeyWithHttpInfo(body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Generic config Get using a full path in the config tree
     * @param {String} FullPath Full slash-separated path to the config key
     * @param {Object} opts Optional parameters
     * @param {String} opts.Data JSON-encoded data to store.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestConfiguration} and HTTP response
     */
    getConfigWithHttpInfo(FullPath, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'FullPath' is set
      if (FullPath === undefined || FullPath === null) {
        throw new Error("Missing the required parameter 'FullPath' when calling getConfig");
      }

      let pathParams = {
        'FullPath': FullPath
      };
      let queryParams = {
        'Data': opts['Data']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = RestConfiguration;
      return this.apiClient.callApi(
        '/config/{FullPath}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Generic config Get using a full path in the config tree
     * @param {String} FullPath Full slash-separated path to the config key
     * @param {Object} opts Optional parameters
     * @param {String} opts.Data JSON-encoded data to store.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestConfiguration}
     */
    getConfig(FullPath, opts) {
      return this.getConfigWithHttpInfo(FullPath, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Load datasource information
     * @param {String} Name Name of the data source (max length 34)
     * @param {Object} opts Optional parameters
     * @param {Boolean} opts.Disabled Whether this data source is disabled or running.
     * @param {module:model/String} opts.StorageType Type of underlying storage (LOCAL, S3, AZURE, GCS). (default to 'LOCAL')
     * @param {String} opts.ObjectsServiceName Corresponding objects service name (underlying s3 service).
     * @param {String} opts.ObjectsHost Corresponding objects service host.
     * @param {Number} opts.ObjectsPort Corresponding objects service port.
     * @param {Boolean} opts.ObjectsSecure Corresponding objects service connection type.
     * @param {String} opts.ObjectsBucket Corresponding objects service bucket.
     * @param {String} opts.ObjectsBaseFolder Corresponding objects service base folder inside the bucket.
     * @param {String} opts.ApiKey Corresponding objects service api key.
     * @param {String} opts.ApiSecret Corresponding objects service api secret.
     * @param {String} opts.PeerAddress Peer address of the data source.
     * @param {Boolean} opts.Watch Not implemented, whether to watch for underlying changes on the FS.
     * @param {Boolean} opts.FlatStorage Store data in flat format (object-storage like).
     * @param {Boolean} opts.SkipSyncOnRestart Do not trigger resync at start.
     * @param {module:model/String} opts.EncryptionMode Type of encryption applied before sending data to storage. (default to 'CLEAR')
     * @param {String} opts.EncryptionKey Encryption key used for encrypting data.
     * @param {String} opts.VersioningPolicyName Versioning policy describes how files are kept in the versioning queue.
     * @param {Number} opts.CreationDate Data Source creation date.
     * @param {Number} opts.LastSynchronizationDate Data Source last synchronization date.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ObjectDataSource} and HTTP response
     */
    getDataSourceWithHttpInfo(Name, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'Name' is set
      if (Name === undefined || Name === null) {
        throw new Error("Missing the required parameter 'Name' when calling getDataSource");
      }

      let pathParams = {
        'Name': Name
      };
      let queryParams = {
        'Disabled': opts['Disabled'],
        'StorageType': opts['StorageType'],
        'ObjectsServiceName': opts['ObjectsServiceName'],
        'ObjectsHost': opts['ObjectsHost'],
        'ObjectsPort': opts['ObjectsPort'],
        'ObjectsSecure': opts['ObjectsSecure'],
        'ObjectsBucket': opts['ObjectsBucket'],
        'ObjectsBaseFolder': opts['ObjectsBaseFolder'],
        'ApiKey': opts['ApiKey'],
        'ApiSecret': opts['ApiSecret'],
        'PeerAddress': opts['PeerAddress'],
        'Watch': opts['Watch'],
        'FlatStorage': opts['FlatStorage'],
        'SkipSyncOnRestart': opts['SkipSyncOnRestart'],
        'EncryptionMode': opts['EncryptionMode'],
        'EncryptionKey': opts['EncryptionKey'],
        'VersioningPolicyName': opts['VersioningPolicyName'],
        'CreationDate': opts['CreationDate'],
        'LastSynchronizationDate': opts['LastSynchronizationDate']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ObjectDataSource;
      return this.apiClient.callApi(
        '/config/datasource/{Name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Load datasource information
     * @param {String} Name Name of the data source (max length 34)
     * @param {Object} opts Optional parameters
     * @param {Boolean} opts.Disabled Whether this data source is disabled or running.
     * @param {module:model/String} opts.StorageType Type of underlying storage (LOCAL, S3, AZURE, GCS). (default to 'LOCAL')
     * @param {String} opts.ObjectsServiceName Corresponding objects service name (underlying s3 service).
     * @param {String} opts.ObjectsHost Corresponding objects service host.
     * @param {Number} opts.ObjectsPort Corresponding objects service port.
     * @param {Boolean} opts.ObjectsSecure Corresponding objects service connection type.
     * @param {String} opts.ObjectsBucket Corresponding objects service bucket.
     * @param {String} opts.ObjectsBaseFolder Corresponding objects service base folder inside the bucket.
     * @param {String} opts.ApiKey Corresponding objects service api key.
     * @param {String} opts.ApiSecret Corresponding objects service api secret.
     * @param {String} opts.PeerAddress Peer address of the data source.
     * @param {Boolean} opts.Watch Not implemented, whether to watch for underlying changes on the FS.
     * @param {Boolean} opts.FlatStorage Store data in flat format (object-storage like).
     * @param {Boolean} opts.SkipSyncOnRestart Do not trigger resync at start.
     * @param {module:model/String} opts.EncryptionMode Type of encryption applied before sending data to storage. (default to 'CLEAR')
     * @param {String} opts.EncryptionKey Encryption key used for encrypting data.
     * @param {String} opts.VersioningPolicyName Versioning policy describes how files are kept in the versioning queue.
     * @param {Number} opts.CreationDate Data Source creation date.
     * @param {Number} opts.LastSynchronizationDate Data Source last synchronization date.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ObjectDataSource}
     */
    getDataSource(Name, opts) {
      return this.getDataSourceWithHttpInfo(Name, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Load a given versioning policy
     * @param {String} Uuid 
     * @param {Object} opts Optional parameters
     * @param {String} opts.Name 
     * @param {String} opts.Description 
     * @param {String} opts.VersionsDataSourceName 
     * @param {String} opts.VersionsDataSourceBucket 
     * @param {String} opts.MaxTotalSize 
     * @param {String} opts.MaxSizePerFile 
     * @param {String} opts.IgnoreFilesGreaterThan 
     * @param {module:model/String} opts.NodeDeletedStrategy  (default to 'KeepAll')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/TreeVersioningPolicy} and HTTP response
     */
    getVersioningPolicyWithHttpInfo(Uuid, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'Uuid' is set
      if (Uuid === undefined || Uuid === null) {
        throw new Error("Missing the required parameter 'Uuid' when calling getVersioningPolicy");
      }

      let pathParams = {
        'Uuid': Uuid
      };
      let queryParams = {
        'Name': opts['Name'],
        'Description': opts['Description'],
        'VersionsDataSourceName': opts['VersionsDataSourceName'],
        'VersionsDataSourceBucket': opts['VersionsDataSourceBucket'],
        'MaxTotalSize': opts['MaxTotalSize'],
        'MaxSizePerFile': opts['MaxSizePerFile'],
        'IgnoreFilesGreaterThan': opts['IgnoreFilesGreaterThan'],
        'NodeDeletedStrategy': opts['NodeDeletedStrategy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = TreeVersioningPolicy;
      return this.apiClient.callApi(
        '/config/versioning/{Uuid}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Load a given versioning policy
     * @param {String} Uuid 
     * @param {Object} opts Optional parameters
     * @param {String} opts.Name 
     * @param {String} opts.Description 
     * @param {String} opts.VersionsDataSourceName 
     * @param {String} opts.VersionsDataSourceBucket 
     * @param {String} opts.MaxTotalSize 
     * @param {String} opts.MaxSizePerFile 
     * @param {String} opts.IgnoreFilesGreaterThan 
     * @param {module:model/String} opts.NodeDeletedStrategy  (default to 'KeepAll')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TreeVersioningPolicy}
     */
    getVersioningPolicy(Uuid, opts) {
      return this.getVersioningPolicyWithHttpInfo(Uuid, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Import a previously exported master key, requires the password created at export time
     * @param {module:model/EncryptionAdminImportKeyRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/EncryptionAdminImportKeyResponse} and HTTP response
     */
    importEncryptionKeyWithHttpInfo(body) {
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling importEncryptionKey");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = EncryptionAdminImportKeyResponse;
      return this.apiClient.callApi(
        '/config/encryption/import', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Import a previously exported master key, requires the password created at export time
     * @param {module:model/EncryptionAdminImportKeyRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EncryptionAdminImportKeyResponse}
     */
    importEncryptionKey(body) {
      return this.importEncryptionKeyWithHttpInfo(body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List all defined datasources
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestDataSourceCollection} and HTTP response
     */
    listDataSourcesWithHttpInfo() {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = RestDataSourceCollection;
      return this.apiClient.callApi(
        '/config/datasource', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List all defined datasources
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestDataSourceCollection}
     */
    listDataSources() {
      return this.listDataSourcesWithHttpInfo()
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List registered master keys
     * @param {module:model/EncryptionAdminListKeysRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/EncryptionAdminListKeysResponse} and HTTP response
     */
    listEncryptionKeysWithHttpInfo(body) {
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling listEncryptionKeys");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = EncryptionAdminListKeysResponse;
      return this.apiClient.callApi(
        '/config/encryption/list', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List registered master keys
     * @param {module:model/EncryptionAdminListKeysRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EncryptionAdminListKeysResponse}
     */
    listEncryptionKeys(body) {
      return this.listEncryptionKeysWithHttpInfo(body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List folders on a peer, starting from root
     * @param {String} PeerAddress Restrict listing to a given peer
     * @param {module:model/RestListPeerFoldersRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestNodesCollection} and HTTP response
     */
    listPeerFoldersWithHttpInfo(PeerAddress, body) {
      let postBody = body;
      // verify the required parameter 'PeerAddress' is set
      if (PeerAddress === undefined || PeerAddress === null) {
        throw new Error("Missing the required parameter 'PeerAddress' when calling listPeerFolders");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling listPeerFolders");
      }

      let pathParams = {
        'PeerAddress': PeerAddress
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = RestNodesCollection;
      return this.apiClient.callApi(
        '/config/peers/{PeerAddress}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List folders on a peer, starting from root
     * @param {String} PeerAddress Restrict listing to a given peer
     * @param {module:model/RestListPeerFoldersRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestNodesCollection}
     */
    listPeerFolders(PeerAddress, body) {
      return this.listPeerFoldersWithHttpInfo(PeerAddress, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List all detected peers (servers on which the app is running)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestListPeersAddressesResponse} and HTTP response
     */
    listPeersAddressesWithHttpInfo() {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = RestListPeersAddressesResponse;
      return this.apiClient.callApi(
        '/config/peers', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List all detected peers (servers on which the app is running)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestListPeersAddressesResponse}
     */
    listPeersAddresses() {
      return this.listPeersAddressesWithHttpInfo()
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List running Processes, with option PeerId or ServiceName filter
     * @param {module:model/RestListProcessesRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestListProcessesResponse} and HTTP response
     */
    listProcessesWithHttpInfo(body) {
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling listProcesses");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = RestListProcessesResponse;
      return this.apiClient.callApi(
        '/config/processes', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List running Processes, with option PeerId or ServiceName filter
     * @param {module:model/RestListProcessesRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestListProcessesResponse}
     */
    listProcesses(body) {
      return this.listProcessesWithHttpInfo(body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * @param {module:model/RegistryListRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RegistryListResponse} and HTTP response
     */
    listRegistryWithHttpInfo(body) {
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling listRegistry");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = RegistryListResponse;
      return this.apiClient.callApi(
        '/config/registry', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * @param {module:model/RegistryListRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RegistryListResponse}
     */
    listRegistry(body) {
      return this.listRegistryWithHttpInfo(body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List all services and their status
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.StatusFilter Filter services by a given status (ANY, STOPPED, STOPPING, RUNNING). (default to 'ANY')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestServiceCollection} and HTTP response
     */
    listServicesWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'StatusFilter': opts['StatusFilter']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = RestServiceCollection;
      return this.apiClient.callApi(
        '/config/ctl', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List all services and their status
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.StatusFilter Filter services by a given status (ANY, STOPPED, STOPPING, RUNNING). (default to 'ANY')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestServiceCollection}
     */
    listServices(opts) {
      return this.listServicesWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List configured sites
     * @param {String} Filter 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestListSitesResponse} and HTTP response
     */
    listSitesWithHttpInfo(Filter) {
      let postBody = null;
      // verify the required parameter 'Filter' is set
      if (Filter === undefined || Filter === null) {
        throw new Error("Missing the required parameter 'Filter' when calling listSites");
      }

      let pathParams = {
        'Filter': Filter
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = RestListSitesResponse;
      return this.apiClient.callApi(
        '/config/sites/{Filter}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List configured sites
     * @param {String} Filter 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestListSitesResponse}
     */
    listSites(Filter) {
      return this.listSitesWithHttpInfo(Filter)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Buckets on a given object storage
     * @param {module:model/RestListStorageBucketsRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestNodesCollection} and HTTP response
     */
    listStorageBucketsWithHttpInfo(body) {
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling listStorageBuckets");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = RestNodesCollection;
      return this.apiClient.callApi(
        '/config/buckets', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Buckets on a given object storage
     * @param {module:model/RestListStorageBucketsRequest} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestNodesCollection}
     */
    listStorageBuckets(body) {
      return this.listStorageBucketsWithHttpInfo(body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List all defined versioning policies
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestVersioningPolicyCollection} and HTTP response
     */
    listVersioningPoliciesWithHttpInfo() {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = RestVersioningPolicyCollection;
      return this.apiClient.callApi(
        '/config/versioning', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List all defined versioning policies
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestVersioningPolicyCollection}
     */
    listVersioningPolicies() {
      return this.listVersioningPoliciesWithHttpInfo()
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List all defined virtual nodes
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestNodesCollection} and HTTP response
     */
    listVirtualNodesWithHttpInfo() {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = RestNodesCollection;
      return this.apiClient.callApi(
        '/config/virtualnodes', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List all defined virtual nodes
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestNodesCollection}
     */
    listVirtualNodes() {
      return this.listVirtualNodesWithHttpInfo()
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Publish available REST APIs
     * @param {Object} opts Optional parameters
     * @param {String} opts.EndpointType Filter result to a specific endpoint type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestOpenApiResponse} and HTTP response
     */
    openApiDiscoveryWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'EndpointType': opts['EndpointType']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = RestOpenApiResponse;
      return this.apiClient.callApi(
        '/config/discovery/openapi', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Publish available REST APIs
     * @param {Object} opts Optional parameters
     * @param {String} opts.EndpointType Filter result to a specific endpoint type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestOpenApiResponse}
     */
    openApiDiscovery(opts) {
      return this.openApiDiscoveryWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Generic config Put, using a full path in the config tree
     * @param {String} FullPath Full slash-separated path to the config key
     * @param {module:model/ConfigurationMessageDataIsAnJsonRepresentationOfAnyValue} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestConfiguration} and HTTP response
     */
    putConfigWithHttpInfo(FullPath, body) {
      let postBody = body;
      // verify the required parameter 'FullPath' is set
      if (FullPath === undefined || FullPath === null) {
        throw new Error("Missing the required parameter 'FullPath' when calling putConfig");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling putConfig");
      }

      let pathParams = {
        'FullPath': FullPath
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = RestConfiguration;
      return this.apiClient.callApi(
        '/config/{FullPath}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Generic config Put, using a full path in the config tree
     * @param {String} FullPath Full slash-separated path to the config key
     * @param {module:model/ConfigurationMessageDataIsAnJsonRepresentationOfAnyValue} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestConfiguration}
     */
    putConfig(FullPath, body) {
      return this.putConfigWithHttpInfo(FullPath, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create or update a datasource
     * @param {String} Name Name of the data source (max length 34)
     * @param {module:model/DataSourceObjectDescription} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ObjectDataSource} and HTTP response
     */
    putDataSourceWithHttpInfo(Name, body) {
      let postBody = body;
      // verify the required parameter 'Name' is set
      if (Name === undefined || Name === null) {
        throw new Error("Missing the required parameter 'Name' when calling putDataSource");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling putDataSource");
      }

      let pathParams = {
        'Name': Name
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = ObjectDataSource;
      return this.apiClient.callApi(
        '/config/datasource/{Name}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create or update a datasource
     * @param {String} Name Name of the data source (max length 34)
     * @param {module:model/DataSourceObjectDescription} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ObjectDataSource}
     */
    putDataSource(Name, body) {
      return this.putDataSourceWithHttpInfo(Name, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Publish scheduler action XML form for building screens in frontend
     * @param {String} ActionName Name of the action to load
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestSchedulerActionFormResponse} and HTTP response
     */
    schedulerActionFormDiscoveryWithHttpInfo(ActionName) {
      let postBody = null;
      // verify the required parameter 'ActionName' is set
      if (ActionName === undefined || ActionName === null) {
        throw new Error("Missing the required parameter 'ActionName' when calling schedulerActionFormDiscovery");
      }

      let pathParams = {
        'ActionName': ActionName
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = RestSchedulerActionFormResponse;
      return this.apiClient.callApi(
        '/config/scheduler/actions/{ActionName}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Publish scheduler action XML form for building screens in frontend
     * @param {String} ActionName Name of the action to load
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestSchedulerActionFormResponse}
     */
    schedulerActionFormDiscovery(ActionName) {
      return this.schedulerActionFormDiscoveryWithHttpInfo(ActionName)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Publish scheduler registered actions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RestSchedulerActionsResponse} and HTTP response
     */
    schedulerActionsDiscoveryWithHttpInfo() {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = RestSchedulerActionsResponse;
      return this.apiClient.callApi(
        '/config/scheduler/actions', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Publish scheduler registered actions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RestSchedulerActionsResponse}
     */
    schedulerActionsDiscovery() {
      return this.schedulerActionsDiscoveryWithHttpInfo()
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


}
